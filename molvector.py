"""molvector

This is set of simple functions that convert molecules to and from
a vector representation.

The representation is quite simple, it consists of block
each of which contains atoms and bonds records.


 [atom_record][bond_records]

These blocks are fixed size and each of these blocks has the property
that they can be moved and mutated between vectors and will
always form a graph[with one exception].  Note that the graph may 
not be chemical.

The only graphs that are not generated contain self references,
i.e. an atom that has a bond to itself.

This property is generated by how the bonds are encoded in the vector.

A bond record has a bond type and an offset.  The offset is the
relative index to the atom to which it is bonded.

I.e. a single bond between atom index 1 and atom index 3 is encoded
 with bond_type=1, bond_offset=2 from atom 1 to atom 3
  and bond_type=1, bond_offset=-2 from atom 3 to atom 1

When the graph is decoded, atom index generated via the offset
is modulo the number of atoms, i.e. can wrap around.

Now it may be that this encoding ends up not being useful,
however I have noted that the MAE in my training sessions
drops faster quicker as there is not as much to learn
as when using smiles strings as inputs.

Additionally, stereochemistry can be encoded correctly
 (this is not yet done:)

By default the encoder generates an ensemble of
molvectors in random but unique smiles orders.  This can take
a bit of time but is easy to parallelize.

 >>> from molvector import encode
 >>> from rdkit.Chem import MolFromSmiles
 >>> test = "NCCCCCOCC1OC(OCCc2c[nH]c3ccccc23)C(OCc2ccccc2)C(OCc2ccccc2)C1OCc1ccccc1"
 >>> m = Chem.MolFromSmiles(test3)
 >>> vectors = encode(m)
 >>> print(len(vectors))

Future work:

There needs to be some heuristic on how many random smiles we should check
for a given size of input.  Currently we try 10,000 times to generate
random smiles for any input size.
"""
import random
from rdkit.Chem import Atom, MolFromSmiles, MolToSmiles, RWMol, BondType, PeriodicTable

atom_size = 3
max_num_bonds = 4
bond_size = 2
bond_chunk_size = max_num_bonds*bond_size

bond_symbols = {}
bond_symbols[int(BondType.AROMATIC)] = "~"
bond_symbols[0] = "."
bond_symbols[int(BondType.SINGLE)] = "-"
bond_symbols[int(BondType.DOUBLE)] = "="
bond_symbols[int(BondType.TRIPLE)] = "#"


def encode_the_atoms_bonds(v, atom, orders):
    """encode the bonds for the given atom
     :param atom: the atom to encode
     :param v: the molvector to append to
     :param orders: the atom orders to use for this mol vector
    """
    idx = orders.index(atom.GetIdx())
    bv = []

    bonds = []
    for bond in atom.GetBonds():
        btype = int(bond.GetBondType())
        bidx, eidx = bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()
        fromatom, toatom = orders.index(bidx), orders.index(eidx)
        
        if fromatom == idx:
            offset = toatom - idx 
        else:
            offset = fromatom - idx
        assert btype > 0
        bonds.append((btype, offset))
    bonds.sort(key=lambda x: x[1])
    for b,o in bonds:
        bv.append(b)
        bv.append(o)

    bv += [0] * (bond_chunk_size-len(bv))
    if len(bv) > bond_chunk_size:
        raise ValueError("Atom %s has more than four bonds %s"%(
            atom.GetIdx(), len(atom.GetBonds())))
    if len(bv) < bond_chunk_size:
        raise ValueError("Atom %s has fewer than four bonds %s"%(
            atom.GetIdx(), len(atom.GetBonds())))

    v.extend(bv)
    
def encode_atom(v, atom, orders):
    """Encode an atom into the mol vector
     :param atom: atom to incode
     :param idx: idx to use for the atom (not necessarily atom.GetIdx())
     :param v: molvector to append to
     :param orders: the list of atom orders for this molvector
    """
    el = atom.GetAtomicNum()
    c = atom.GetFormalCharge()
    h = atom.GetTotalNumHs()
    v.append( el )
    v.append( c )
    v.append( h )
    encode_the_atoms_bonds(v, atom, orders)

def canonical_order(mol):
    """Return the canonical ordering for the molecule"""
    s = MolToSmiles(mol)
    order = tuple(eval(mol.GetProp("_smilesAtomOutputOrder")))
    yield order

def generate_random_smiles_orders(mol, N=100000):
    """Generate random smiles-output orders from a molecule

     :param mol: the molecule to randomize
     :param N: number of randomizations
    
     :results generator of atom orders, where the
              index is the atom, and the value is the
              new order for the specified atom.:
    """
    idxs = list(range(0,mol.GetNumAtoms()))
    s = set()
    mol.SetProp("_canonicalRankingNumbers", "True")
    orders = []
    
    for j in range(N):
        smiles = MolToSmiles(mol, doRandom=True)
        if smiles not in s:
            s.add(smiles)
            yield tuple(eval(mol.GetProp("_smilesAtomOutputOrder")))
        continue

def encode(mol, generator=generate_random_smiles_orders):
    """Encode a molecule given a list of atom orderings
    
      :param mol: the molecule to encode
      :param generator: a generator that returns atom orderings
                                 [default generate_smiles_orders]

      :result list of encodings, one per atom ordering produced by
                         the generator:
    """
    # swap up atoms
    result = []
    orders = generator(mol)

    for i, order in enumerate(orders):
        v = []
        
        for idx in order:
            atom = mol.GetAtomWithIdx(idx)
            encode_atom(v, atom, order)
        result.append(v)
    return result

def decode(v):
    """Decode a molvector into a molecule

     :param v: molvector
     :result rdkit.RWMol:
    """
    chunksize = atom_size+bond_chunk_size
    nchunks = len(v)//chunksize
    m = RWMol()

    bonds = {}
    
    for i in range(nchunks):
        start = i*(atom_size+bond_chunk_size)

        el, c, h,b1,o1,b2,o2,b3,o3,b4,o4 = v[start:start+chunksize]
        
        atom = Atom(el)
        atom.SetFormalCharge(c)
        atom.SetNumExplicitHs(h)
        atom_idx = m.AddAtom(atom)
        assert atom_idx == i

        for b, o in ((b1, o1), (b2, o2), (b3, o3), (b4, o4)):
            if o:
                to_atom = atom_idx + o
                bonds[ tuple(sorted((atom_idx, to_atom))) ]  = b
                
    for (a1,a2), btype in bonds.items():
        try:
            m.AddBond(a1%m.GetNumAtoms(),a2%m.GetNumAtoms(),BondType.values[btype])
        except:
            pass
    return m
            
def toStringRep(v):
    """Generate a string representation of a molvector
      :param v: molvector
    """
    p = GetPeriodicTable()
    chunksize = atom_size+bond_chunk_size
    nchunks = len(v)//chunksize
    m = RWMol()
    out = []
    for i in range(nchunks):
        start = i*(atom_size+bond_chunk_size)
        el, c, h,b1,o1,b2,o2,b3,o3,b4,o4 = v[start:start+chunksize]
        el = ("%2s"%p.GetElementSymbol(el)).replace(" ", "_")
        out.append(el)
        assert c<10
        out.append(str(c))
        assert h<10
        out.append(str(h))
        for btype, o in ((b1,o1),(b2,o2),(b3,o3),(b4,o4)):
            out.append( bond_symbols[btype] )
            out.append( "%04d"%o )
    return "".join(out)

def mutate(v, v2):
    """Given two molecules, randomly mutate a chunk of one
    into the a chunk of the other"""
    chunksize = atom_size+bond_chunk_size
    n1 = len(v)//chunksize
    n2 = len(v2)//chunksize
    import random
    a = random.randint(0,n1)
    b = random.randint(0,n1)
    if a>b:
        a,b=b,a
    a,b = a*chunksize, b*chunksize
    a2 = random.randint(0,n2)
    b2 = random.randint(0,n2)
    if a2>b2:
        a2,b2=b2,a2
    a2,b2 = a2*chunksize, b2*chunksize
    chunk = v[a:b]
    head, rest = v2[:a2], v2[b2:]
    return head + chunk + rest
    
                
        


